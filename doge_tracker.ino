
#define double_buffer
#include <PxMatrix.h>

#ifdef ESP32
#gitignore ignore me

#define P_LAT 22
#define P_A 19
#define P_B 23
#define P_C 18
#define P_D 5
#define P_E 15
#define P_OE 2
hw_timer_t * timer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

#endif

#include <wifi_credentials.h>
#include <ESP8266WiFi.h>
#include <WiFiUdp.h>

#include <Ticker.h>
Ticker display_ticker;
#define P_LAT 16
#define P_A 5
#define P_B 4
#define P_C 15
#define P_D 12
#define P_E 0
#define P_OE 2

// Pins for LED MATRIX

int xspeed=2;

uint16_t static doge[]={0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0010 (16) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0020 (32) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0030 (48) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0040 (64) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0050 (80) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0060 (96) pixels
0x0000, 0x0000, 0x0000, 0x3184, 0x4205, 0x39C5, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2123, 0x2943, 0x0000, 0x0000,   // 0x0070 (112) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0080 (128) pixels
0x0000, 0xC5F1, 0xF795, 0xDEB3, 0x39C5, 0x0000, 0x0000, 0x0000, 0x0000, 0x2943, 0xA50E, 0xB56F, 0x2123, 0x0000, 0x0000, 0x0000,   // 0x0090 (144) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3184, 0xCE52,   // 0x00A0 (160) pixels
0xF795, 0xF795, 0xFF31, 0x3960, 0x3940, 0x3940, 0x3940, 0xC58C, 0xFF31, 0xFF31, 0x9C6A, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x00B0 (176) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xCE72, 0xF775, 0xFF52, 0xFEEF,   // 0x00C0 (192) pixels
0xFDC2, 0xF561, 0xF561, 0xF561, 0xF561, 0xFDA2, 0xFDC2, 0xFDC2, 0xB401, 0x3940, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x00D0 (208) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xDEB3, 0xFF32, 0xFE05, 0xFDA1, 0xFDA1, 0xFDA1,   // 0x00E0 (224) pixels
0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0x1060, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x00F0 (240) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x20C0, 0xDE90, 0xFE05, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1,   // 0x0100 (256) pixels
0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0x1060, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0110 (272) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xF561, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1,   // 0x0120 (288) pixels
0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0x2900, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0130 (304) pixels
0x0000, 0x0000, 0x20A0, 0xF561, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xC461, 0x9320,   // 0x0140 (320) pixels
0x9320, 0x9320, 0xFD81, 0x18A0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1880,   // 0x0150 (336) pixels
0xED41, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xED61, 0x9340, 0x9340, 0x9340, 0xF561, 0xFDA1, 0xFDA1, 0x8B00, 0x18A0, 0x18A0, 0x18A0,   // 0x0160 (352) pixels
0xF561, 0x18A0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x3120, 0xFDA1, 0xFDA1,   // 0x0170 (368) pixels
0xFDA1, 0xFDA1, 0xFDA1, 0xDCE1, 0x1880, 0x1880, 0x1880, 0xE521, 0xFDA1, 0xFDA1, 0xED21, 0xD4C1, 0xD4C1, 0xD4C1, 0xFDA1, 0x3120,   // 0x0180 (384) pixels
0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3120, 0xCC81, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1,   // 0x0190 (400) pixels
0xFDA1, 0xF581, 0xC461, 0xC461, 0xC461, 0xFD81, 0xFDA1, 0xFDA1, 0xFD81, 0xF561, 0xF561, 0xF561, 0xF561, 0xCCA2, 0x3120, 0x0000,   // 0x01A0 (416) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4180, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1,   // 0x01B0 (432) pixels
0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDA1, 0xA3A1, 0x49A0, 0x49A0, 0x49A0, 0x49A0, 0xE68C, 0x39C3, 0x0000, 0x0000, 0x0000,   // 0x01C0 (448) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4180, 0xFDA1, 0xFDA1, 0xFDA1, 0xFDC2, 0xFF6E, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2,   // 0x01D0 (464) pixels
0xFECA, 0xFDE3, 0xFDC2, 0xFDC1, 0xFDA1, 0x9B80, 0x0000, 0x0000, 0x0000, 0xDEF0, 0x39E4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x01E0 (480) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x4180, 0xFDA1, 0xFDA1, 0xFDA1, 0xFF4E, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFF90,   // 0x01F0 (496) pixels
0xFF90, 0xFE46, 0xFDC2, 0xA3C1, 0x0840, 0x0000, 0x0860, 0xDEF0, 0x39E4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0200 (512) pixels
0x0000, 0x0000, 0x4180, 0xFDA1, 0xFDA1, 0xFDA1, 0xFF90, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xF791, 0xEF71, 0xEF2E,   // 0x0210 (528) pixels
0xEEED, 0xDE8D, 0x7BC8, 0x1081, 0xBDCD, 0xF792, 0x39E4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0220 (544) pixels
0x4180, 0xFDA1, 0xFDA1, 0xFDA1, 0xFF90, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0x6B68, 0x5AC6, 0x5AC6, 0x5AC6, 0x5AC6,   // 0x0230 (560) pixels
0x7BE9, 0xAD4C, 0xF7B2, 0xFFD2, 0x39E5, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4180, 0xFDA1,   // 0x0240 (576) pixels
0xFDA1, 0xFDA1, 0xFF90, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xAD4C, 0x9CEB, 0x9CEB, 0x9CEB, 0x9CEB, 0xC60E, 0xFFD2,   // 0x0250 (592) pixels
0xFFD2, 0xFFD2, 0x39E4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4180, 0xFDA1, 0xFDA1, 0xFDA1,   // 0x0260 (608) pixels
0xFF90, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0x8409,   // 0x0270 (624) pixels
0x18E2, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x20A0, 0x8300, 0xFDA1, 0xFDA1, 0xFE88, 0xFF90,   // 0x0280 (640) pixels
0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0x18E2, 0x0000, 0x0000,   // 0x0290 (656) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x18A0, 0xFDA1, 0xFDA1, 0xFDA1, 0xFF4E, 0xFFD2, 0xFFD2,   // 0x02A0 (672) pixels
0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0x4225, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x02B0 (688) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0840, 0x6A60, 0xF581, 0xFDA1, 0xFE47, 0xFF70, 0xFFD2, 0xFFD2, 0xFFD2,   // 0x02C0 (704) pixels
0xFFD2, 0xF7B2, 0xFFD2, 0xFFD2, 0xFFD2, 0xFFD2, 0xC60E, 0x6B68, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x02D0 (720) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x7AA0, 0x82E0, 0x82E0, 0x7BA7, 0x7BE9, 0x7BE9, 0x7BE9, 0x7BE9, 0x7BCA,   // 0x02E0 (736) pixels
0x7BE9, 0x7BE9, 0x7BE9, 0x7BE9, 0x4A65, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x02F0 (752) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0300 (768) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0310 (784) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0320 (800) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0330 (816) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0340 (832) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0350 (848) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0360 (864) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0370 (880) pixels
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0380 (896) pixels
};// 0x0240 (576) pixels};
//PxMATRIX display(32,16,P_LAT, P_OE,P_A,P_B,P_C);
PxMATRIX display(64, 32, P_LAT, P_OE, P_A, P_B, P_C, P_D);
//PxMATRIX display(64,64,P_LAT, P_OE,P_A,P_B,P_C,P_D,P_E);
WiFiUDP Udp;
#ifdef ESP8266
// ISR for display refresh
void display_updater()
{
  display.display(70);
}
#endif

#ifdef ESP32
void IRAM_ATTR display_updater() {
  // Increment the counter and set the time of ISR
  portENTER_CRITICAL_ISR(&timerMux);
  display.display(70);
  portEXIT_CRITICAL_ISR(&timerMux);
}
#endif
String txt;
struct Text {
  char *text;
  uint16_t width, height;
  int16_t x, y;
  int16_t dx, dy;
} text = {"Hello", 0, 0, 0, 0, 1, 1};

char packetBuffer[UDP_TX_PACKET_MAX_SIZE + 1]; //buffer to hold incoming packet,

uint16_t textColor = display.color565(0, 0, 255);
uint16_t myBLACK = display.color565(0, 0, 0);
uint16_t lineColor = display.color565(255, 0, 0);
uint16_t backgroundColor = display.color565(0, 255, 0);
unsigned int localPort = 8888;      // local port to listen on
byte convertTwoBytes(char packetBuffer[]) {
  //take two Hex characters at the provided address and return the byte value
  //Must check that characters are valid hex before passing to this function
  byte temp = 0;
  if(packetBuffer[0]>='0' && packetBuffer[0]<='9') temp = packetBuffer[0] - '0';
  if(packetBuffer[0]>='A' && packetBuffer[0]<='F') temp = packetBuffer[0] - 'A' + 10;
  if(packetBuffer[0]>='a' && packetBuffer[0]<='f') temp = packetBuffer[0] - 'a' + 10;
  temp *= 0x10;
  if(packetBuffer[1]>='0' && packetBuffer[1]<='9') temp += packetBuffer[1] - '0';
  if(packetBuffer[1]>='A' && packetBuffer[1]<='F') temp += packetBuffer[1] - 'A' + 10;
  if(packetBuffer[1]>='a' && packetBuffer[1]<='f') temp += packetBuffer[1] - 'a' + 10;
  return temp;
}

bool convertRGB(char packetBuffer[], byte &R, byte &G, byte &B) {
  //return false if the provided array could not be converted, true if valid values put into R, G and B.
  if(packetBuffer[0] != '#') return false;
  if(strlen(packetBuffer) != 7) return false;
  for(byte i=1; i<7; i++) {
    //note this relies on certain properties of the ASCII characters: 0-9 occurs before A-Z occurs before a-z
    if(packetBuffer[i] < '0') return false;
    if(packetBuffer[i] > '9' && packetBuffer[i] < 'A') return false;
    if(packetBuffer[i] > 'F' && packetBuffer[i] < 'a') return false;
    if(packetBuffer[i] > 'f') return false;
  }
  R = convertTwoBytes(&packetBuffer[1]);
  G = convertTwoBytes(&packetBuffer[3]);
  B = convertTwoBytes(&packetBuffer[5]);
  return true;
}
void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  WiFi.begin(STASSID, STAPSK);
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(500);
  }
  Serial.print("Connected! IP address: ");
  Serial.println(WiFi.localIP());
  Serial.printf("UDP server on port %d\n", localPort);
  Udp.begin(localPort);
    Serial.println(WiFi.localIP());

  display.begin(16);
  display.setMuxPattern(SHIFTREG_ABC_BIN_DE);
  //display.setScanPattern(WZAGZIG);
  
  display.flushDisplay();
  display.setTextWrap(true);
  //display.clearDisplay();
  Serial.print("Pixel draw latency in us: ");
  unsigned long start_timer = micros();
  display.drawPixel(1, 1, 0);
  unsigned long delta_timer = micros() - start_timer;
  Serial.println(delta_timer);

  //Serial.print("Display update latency in us: ");
  start_timer = micros();
  display.display(0);
  delta_timer = micros() - start_timer;
  //Serial.println(delta_timer);
  Serial.println("setup");

  display_ticker.attach(0.002, display_updater);
  yield();
  display.clearDisplay();
  //drawImage(0, 0);
  delay(500);



#ifdef ESP8266
  display_ticker.attach(0.004, display_updater);
#endif


  int16_t x1 = 0, y1 = 0;
  display.getTextBounds(text.text, 0, 0, &x1, &y1, &text.width, &text.height);
  text.width -= 2;
  text.height -= 2;
}

int16_t x = 0, dx = 1;

void drawImage2(int x, int y)
{
 int imageHeight = 30;
 int imageWidth = 30;
 int counter = 0;
 for (int yy = 0; yy < imageHeight; yy++)
 {
   for (int xx = 0; xx < imageWidth; xx++)
   {
     display.drawPixel(xx + x , yy + y, doge[counter]);
     counter++;
   }
 }
}
void loop() {
  //  display.clearDisplay();
  int packetSize = Udp.parsePacket();

  if (packetSize) {
    display.fillScreen(myBLACK);
    // read the packet into packetBufffer
    int r, g, b;
    int n = Udp.read(packetBuffer, UDP_TX_PACKET_MAX_SIZE);
    
    //if (packetSize <= 18) {
      int s = sscanf(packetBuffer, "%d %d %d", &r, &g, &b);
if (s==3){
      
    //}

  //uint16_t color=convertRGB(packetBuffer, r, g, b);
//Serial.println("r"+r);
//Serial.println("g"+g);
//Serial.println("b"+b);
    textColor =  display.color565(r, g, b);
}
else{
  
    packetBuffer[n] = 0;
    txt = packetBuffer;


    //  if(x+dx>=display.width() || x+dx<0)
    //    dx=-dx;
    //  x+=dx;
    //  display.drawLine(x,0, display.width()-x-1, display.height()-1, lineColor);

    //  if(text.x+text.dx+text.width>=display.width() || text.x+text.dx<0)
    //    text.dx=-text.dx;
    //  if(text.y+text.dy+text.height>=display.height() || text.y+text.dy<0)
    //    text.dy=-text.dy;
    //  text.x+=text.dx;
    //  text.y+=text.dy;    
    drawImage2(x, 6);
    drawImage2(x+30, 6);
    drawImage2(x-30, 6);
    drawImage2(x-60, 6);
    display.setTextColor(textColor);
    display.setCursor(text.x, text.y);
//    if(s!=3){
      display.print(txt);    
//    }


    display.showBuffer();
    x+=xspeed;
    if(x>=60){
      x=0;
    }
  }
  delay(20);
  }
  }
